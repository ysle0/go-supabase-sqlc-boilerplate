// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user_stats.query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const genUserQuestionStats = `-- name: GenUserQuestionStats :many
SELECT c.name AS category_name,
    q.game_type_id AS game_type,
    COUNT(DISTINCT q.id) AS total_question_count,
    COUNT(
        DISTINCT CASE
            WHEN up.status != 'unsolved'::public.question_status THEN up.question_id
        END
    ) AS answered_question_count,
    COUNT(
        DISTINCT CASE
            WHEN up.status = 'correct'::public.question_status THEN up.question_id
        END
    ) AS correct_question_count
FROM public.questions AS q
    LEFT OUTER JOIN public.categories AS c ON q.category_id = c.id
    LEFT OUTER JOIN public.user_progresses AS up ON up.question_id = q.id
    AND up.user_id = $1
GROUP BY c.id,
    c.name,
    q.game_type_id
ORDER BY c.name
`

type GenUserQuestionStatsRow struct {
	CategoryName          pgtype.Text `db:"category_name" json:"category_name"`
	GameType              int32       `db:"game_type" json:"game_type"`
	TotalQuestionCount    int64       `db:"total_question_count" json:"total_question_count"`
	AnsweredQuestionCount int64       `db:"answered_question_count" json:"answered_question_count"`
	CorrectQuestionCount  int64       `db:"correct_question_count" json:"correct_question_count"`
}

// GenUserQuestionStats
//
//	SELECT c.name AS category_name,
//	    q.game_type_id AS game_type,
//	    COUNT(DISTINCT q.id) AS total_question_count,
//	    COUNT(
//	        DISTINCT CASE
//	            WHEN up.status != 'unsolved'::public.question_status THEN up.question_id
//	        END
//	    ) AS answered_question_count,
//	    COUNT(
//	        DISTINCT CASE
//	            WHEN up.status = 'correct'::public.question_status THEN up.question_id
//	        END
//	    ) AS correct_question_count
//	FROM public.questions AS q
//	    LEFT OUTER JOIN public.categories AS c ON q.category_id = c.id
//	    LEFT OUTER JOIN public.user_progresses AS up ON up.question_id = q.id
//	    AND up.user_id = $1
//	GROUP BY c.id,
//	    c.name,
//	    q.game_type_id
//	ORDER BY c.name
func (q *Queries) GenUserQuestionStats(ctx context.Context, userID int64) ([]GenUserQuestionStatsRow, error) {
	rows, err := q.db.Query(ctx, genUserQuestionStats, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GenUserQuestionStatsRow
	for rows.Next() {
		var i GenUserQuestionStatsRow
		if err := rows.Scan(
			&i.CategoryName,
			&i.GameType,
			&i.TotalQuestionCount,
			&i.AnsweredQuestionCount,
			&i.CorrectQuestionCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserQuestionStats = `-- name: GetUserQuestionStats :many
SELECT answered_question_count,
    total_question_count,
    correct_question_count,
    category_name
FROM user_question_stats
WHERE user_id = $1
`

type GetUserQuestionStatsRow struct {
	AnsweredQuestionCount int32  `db:"answered_question_count" json:"answered_question_count"`
	TotalQuestionCount    int32  `db:"total_question_count" json:"total_question_count"`
	CorrectQuestionCount  int32  `db:"correct_question_count" json:"correct_question_count"`
	CategoryName          string `db:"category_name" json:"category_name"`
}

// GetUserQuestionStats
//
//	SELECT answered_question_count,
//	    total_question_count,
//	    correct_question_count,
//	    category_name
//	FROM user_question_stats
//	WHERE user_id = $1
func (q *Queries) GetUserQuestionStats(ctx context.Context, userID int64) ([]GetUserQuestionStatsRow, error) {
	rows, err := q.db.Query(ctx, getUserQuestionStats, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserQuestionStatsRow
	for rows.Next() {
		var i GetUserQuestionStatsRow
		if err := rows.Scan(
			&i.AnsweredQuestionCount,
			&i.TotalQuestionCount,
			&i.CorrectQuestionCount,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
