// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: event_packages.query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEpDuration = `-- name: CreateEpDuration :exec
INSERT INTO ep_durations
    (user_id, event_package_id, expired_at)
VALUES ($1, $2, $3)
`

type CreateEpDurationParams struct {
	UserID         int64              `db:"user_id" json:"user_id"`
	EventPackageID int32              `db:"event_package_id" json:"event_package_id"`
	ExpiredAt      pgtype.Timestamptz `db:"expired_at" json:"expired_at"`
}

// CreateEpDuration
//
//	INSERT INTO ep_durations
//	    (user_id, event_package_id, expired_at)
//	VALUES ($1, $2, $3)
func (q *Queries) CreateEpDuration(ctx context.Context, arg CreateEpDurationParams) error {
	_, err := q.db.Exec(ctx, createEpDuration, arg.UserID, arg.EventPackageID, arg.ExpiredAt)
	return err
}

const createEpTransaction = `-- name: CreateEpTransaction :exec
INSERT INTO ep_transactions (user_id,
                             event_package_id,
                             purchased_quantity,
                             purchased_at,
                             price_at_purchase,
                             price_unit_at_purchase)
VALUES ($1, $2, 1, NOW(), $3, $4)
`

type CreateEpTransactionParams struct {
	UserID              int64  `db:"user_id" json:"user_id"`
	EventPackageID      int32  `db:"event_package_id" json:"event_package_id"`
	PriceAtPurchase     string `db:"price_at_purchase" json:"price_at_purchase"`
	PriceUnitAtPurchase string `db:"price_unit_at_purchase" json:"price_unit_at_purchase"`
}

// CreateEpTransaction
//
//	INSERT INTO ep_transactions (user_id,
//	                             event_package_id,
//	                             purchased_quantity,
//	                             purchased_at,
//	                             price_at_purchase,
//	                             price_unit_at_purchase)
//	VALUES ($1, $2, 1, NOW(), $3, $4)
func (q *Queries) CreateEpTransaction(ctx context.Context, arg CreateEpTransactionParams) error {
	_, err := q.db.Exec(ctx, createEpTransaction,
		arg.UserID,
		arg.EventPackageID,
		arg.PriceAtPurchase,
		arg.PriceUnitAtPurchase,
	)
	return err
}

const getAllEventPackageIds = `-- name: GetAllEventPackageIds :many
SELECT id
FROM event_packages
`

// GetAllEventPackageIds
//
//	SELECT id
//	FROM event_packages
func (q *Queries) GetAllEventPackageIds(ctx context.Context) ([]int32, error) {
	rows, err := q.db.Query(ctx, getAllEventPackageIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEpDuration = `-- name: GetEpDuration :one
SELECT user_id, event_package_id, started_at, expired_at, updated_at
FROM ep_durations
WHERE user_id = $1
  AND event_package_id = $2
`

type GetEpDurationParams struct {
	UserID         int64 `db:"user_id" json:"user_id"`
	EventPackageID int32 `db:"event_package_id" json:"event_package_id"`
}

// GetEpDuration
//
//	SELECT user_id, event_package_id, started_at, expired_at, updated_at
//	FROM ep_durations
//	WHERE user_id = $1
//	  AND event_package_id = $2
func (q *Queries) GetEpDuration(ctx context.Context, arg GetEpDurationParams) (EpDuration, error) {
	row := q.db.QueryRow(ctx, getEpDuration, arg.UserID, arg.EventPackageID)
	var i EpDuration
	err := row.Scan(
		&i.UserID,
		&i.EventPackageID,
		&i.StartedAt,
		&i.ExpiredAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEventPackageAllRewards = `-- name: GetEventPackageAllRewards :many
SELECT er.gem_quantity,
       er.coin_quantity,
       er.skip_quantity,
       er.hint_quantity,
       er.remove_quantity
FROM event_packages AS ep
         JOIN event_package_rewards as epr ON ep.id = epr.event_package_id
         JOIN ep_rewards AS er ON er.id = epr.ep_reward_id
WHERE type = $1
`

type GetEventPackageAllRewardsRow struct {
	GemQuantity    int32 `db:"gem_quantity" json:"gem_quantity"`
	CoinQuantity   int32 `db:"coin_quantity" json:"coin_quantity"`
	SkipQuantity   int32 `db:"skip_quantity" json:"skip_quantity"`
	HintQuantity   int32 `db:"hint_quantity" json:"hint_quantity"`
	RemoveQuantity int32 `db:"remove_quantity" json:"remove_quantity"`
}

// GetEventPackageAllRewards
//
//	SELECT er.gem_quantity,
//	       er.coin_quantity,
//	       er.skip_quantity,
//	       er.hint_quantity,
//	       er.remove_quantity
//	FROM event_packages AS ep
//	         JOIN event_package_rewards as epr ON ep.id = epr.event_package_id
//	         JOIN ep_rewards AS er ON er.id = epr.ep_reward_id
//	WHERE type = $1
func (q *Queries) GetEventPackageAllRewards(ctx context.Context, type_ EventPackageType) ([]GetEventPackageAllRewardsRow, error) {
	rows, err := q.db.Query(ctx, getEventPackageAllRewards, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventPackageAllRewardsRow
	for rows.Next() {
		var i GetEventPackageAllRewardsRow
		if err := rows.Scan(
			&i.GemQuantity,
			&i.CoinQuantity,
			&i.SkipQuantity,
			&i.HintQuantity,
			&i.RemoveQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventPackageById = `-- name: GetEventPackageById :one
SELECT id, display_name, max_purchase_quantity, expiry_duration, type
FROM event_packages
WHERE id = $1
`

// GetEventPackageById
//
//	SELECT id, display_name, max_purchase_quantity, expiry_duration, type
//	FROM event_packages
//	WHERE id = $1
func (q *Queries) GetEventPackageById(ctx context.Context, id int32) (EventPackage, error) {
	row := q.db.QueryRow(ctx, getEventPackageById, id)
	var i EventPackage
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.MaxPurchaseQuantity,
		&i.ExpiryDuration,
		&i.Type,
	)
	return i, err
}

const getEventPackageSpawnTables = `-- name: GetEventPackageSpawnTables :many
SELECT ep.type,
       st.spawn_probability,
       st.next_id
FROM ep_spawn_tables st
         JOIN event_packages ep ON ep.id = st.event_package_id
ORDER BY ep.id
`

type GetEventPackageSpawnTablesRow struct {
	Type             EventPackageType `db:"type" json:"type"`
	SpawnProbability int32            `db:"spawn_probability" json:"spawn_probability"`
	NextID           pgtype.Int4      `db:"next_id" json:"next_id"`
}

// GetEventPackageSpawnTables
//
//	SELECT ep.type,
//	       st.spawn_probability,
//	       st.next_id
//	FROM ep_spawn_tables st
//	         JOIN event_packages ep ON ep.id = st.event_package_id
//	ORDER BY ep.id
func (q *Queries) GetEventPackageSpawnTables(ctx context.Context) ([]GetEventPackageSpawnTablesRow, error) {
	rows, err := q.db.Query(ctx, getEventPackageSpawnTables)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventPackageSpawnTablesRow
	for rows.Next() {
		var i GetEventPackageSpawnTablesRow
		if err := rows.Scan(&i.Type, &i.SpawnProbability, &i.NextID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventPackageTypeById = `-- name: GetEventPackageTypeById :one
SELECT type
FROM event_packages
WHERE id = $1
`

// GetEventPackageTypeById
//
//	SELECT type
//	FROM event_packages
//	WHERE id = $1
func (q *Queries) GetEventPackageTypeById(ctx context.Context, id int32) (EventPackageType, error) {
	row := q.db.QueryRow(ctx, getEventPackageTypeById, id)
	var type_ EventPackageType
	err := row.Scan(&type_)
	return type_, err
}

const getEventPackagesByType = `-- name: GetEventPackagesByType :many
SELECT id, display_name, max_purchase_quantity, expiry_duration, type
FROM event_packages
WHERE type = $1
`

// GetEventPackagesByType
//
//	SELECT id, display_name, max_purchase_quantity, expiry_duration, type
//	FROM event_packages
//	WHERE type = $1
func (q *Queries) GetEventPackagesByType(ctx context.Context, type_ EventPackageType) ([]EventPackage, error) {
	rows, err := q.db.Query(ctx, getEventPackagesByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventPackage
	for rows.Next() {
		var i EventPackage
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.MaxPurchaseQuantity,
			&i.ExpiryDuration,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPackageTransactions = `-- name: GetUserPackageTransactions :many
SELECT ep.type,
       tx.purchased_quantity,
       ep.max_purchase_quantity,
       epr.event_package_id, epr.ep_reward_id, epr.reward_order
FROM ep_transactions tx
         JOIN event_packages ep ON tx.event_package_id = ep.id
         JOIN event_package_rewards epr ON epr.event_package_id = ep.id
WHERE tx.user_id = $1
`

type GetUserPackageTransactionsRow struct {
	Type                EventPackageType `db:"type" json:"type"`
	PurchasedQuantity   int32            `db:"purchased_quantity" json:"purchased_quantity"`
	MaxPurchaseQuantity int32            `db:"max_purchase_quantity" json:"max_purchase_quantity"`
	EventPackageID      int32            `db:"event_package_id" json:"event_package_id"`
	EpRewardID          int32            `db:"ep_reward_id" json:"ep_reward_id"`
	RewardOrder         int32            `db:"reward_order" json:"reward_order"`
}

// GetUserPackageTransactions
//
//	SELECT ep.type,
//	       tx.purchased_quantity,
//	       ep.max_purchase_quantity,
//	       epr.event_package_id, epr.ep_reward_id, epr.reward_order
//	FROM ep_transactions tx
//	         JOIN event_packages ep ON tx.event_package_id = ep.id
//	         JOIN event_package_rewards epr ON epr.event_package_id = ep.id
//	WHERE tx.user_id = $1
func (q *Queries) GetUserPackageTransactions(ctx context.Context, userID int64) ([]GetUserPackageTransactionsRow, error) {
	rows, err := q.db.Query(ctx, getUserPackageTransactions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPackageTransactionsRow
	for rows.Next() {
		var i GetUserPackageTransactionsRow
		if err := rows.Scan(
			&i.Type,
			&i.PurchasedQuantity,
			&i.MaxPurchaseQuantity,
			&i.EventPackageID,
			&i.EpRewardID,
			&i.RewardOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEpDuration = `-- name: UpdateEpDuration :exec
UPDATE ep_durations
SET started_at = $3,
    expired_at = $4
WHERE user_id = $1
  AND event_package_id = $2
`

type UpdateEpDurationParams struct {
	UserID         int64              `db:"user_id" json:"user_id"`
	EventPackageID int32              `db:"event_package_id" json:"event_package_id"`
	StartedAt      pgtype.Timestamptz `db:"started_at" json:"started_at"`
	ExpiredAt      pgtype.Timestamptz `db:"expired_at" json:"expired_at"`
}

// UpdateEpDuration
//
//	UPDATE ep_durations
//	SET started_at = $3,
//	    expired_at = $4
//	WHERE user_id = $1
//	  AND event_package_id = $2
func (q *Queries) UpdateEpDuration(ctx context.Context, arg UpdateEpDurationParams) error {
	_, err := q.db.Exec(ctx, updateEpDuration,
		arg.UserID,
		arg.EventPackageID,
		arg.StartedAt,
		arg.ExpiredAt,
	)
	return err
}
