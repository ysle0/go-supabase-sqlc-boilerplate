// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: progresses.query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getNextChallengeModeQuestion = `-- name: GetNextChallengeModeQuestion :one
SELECT q.text,
       q.choices,
       q.explanation,
       q.answer_index,
       q.id
FROM user_progresses as up
         JOIN questions q ON up.question_id = q.id
WHERE user_id = $1
  AND status = 'unsolved'
  AND q.game_type_id = $2
`

type GetNextChallengeModeQuestionParams struct {
	UserID     int64 `db:"user_id" json:"user_id"`
	GameTypeID int32 `db:"game_type_id" json:"game_type_id"`
}

type GetNextChallengeModeQuestionRow struct {
	Text        string      `db:"text" json:"text"`
	Choices     []string    `db:"choices" json:"choices"`
	Explanation pgtype.Text `db:"explanation" json:"explanation"`
	AnswerIndex int32       `db:"answer_index" json:"answer_index"`
	ID          int32       `db:"id" json:"id"`
}

// GetNextChallengeModeQuestion
//
//	SELECT q.text,
//	       q.choices,
//	       q.explanation,
//	       q.answer_index,
//	       q.id
//	FROM user_progresses as up
//	         JOIN questions q ON up.question_id = q.id
//	WHERE user_id = $1
//	  AND status = 'unsolved'
//	  AND q.game_type_id = $2
func (q *Queries) GetNextChallengeModeQuestion(ctx context.Context, arg GetNextChallengeModeQuestionParams) (GetNextChallengeModeQuestionRow, error) {
	row := q.db.QueryRow(ctx, getNextChallengeModeQuestion, arg.UserID, arg.GameTypeID)
	var i GetNextChallengeModeQuestionRow
	err := row.Scan(
		&i.Text,
		&i.Choices,
		&i.Explanation,
		&i.AnswerIndex,
		&i.ID,
	)
	return i, err
}

const getNextClassicModeQuestion = `-- name: GetNextClassicModeQuestion :one
SELECT q.text,
       q.choices,
       q.explanation,
       q.answer_index,
       q.id
FROM user_progresses as up
         JOIN questions q ON up.question_id = q.id
WHERE user_id = $1
  AND status = 'unsolved'
  AND q.game_type_id = $2
  AND q.category_id = $3
`

type GetNextClassicModeQuestionParams struct {
	UserID     int64       `db:"user_id" json:"user_id"`
	GameTypeID int32       `db:"game_type_id" json:"game_type_id"`
	CategoryID pgtype.Int4 `db:"category_id" json:"category_id"`
}

type GetNextClassicModeQuestionRow struct {
	Text        string      `db:"text" json:"text"`
	Choices     []string    `db:"choices" json:"choices"`
	Explanation pgtype.Text `db:"explanation" json:"explanation"`
	AnswerIndex int32       `db:"answer_index" json:"answer_index"`
	ID          int32       `db:"id" json:"id"`
}

// GetNextClassicModeQuestion
//
//	SELECT q.text,
//	       q.choices,
//	       q.explanation,
//	       q.answer_index,
//	       q.id
//	FROM user_progresses as up
//	         JOIN questions q ON up.question_id = q.id
//	WHERE user_id = $1
//	  AND status = 'unsolved'
//	  AND q.game_type_id = $2
//	  AND q.category_id = $3
func (q *Queries) GetNextClassicModeQuestion(ctx context.Context, arg GetNextClassicModeQuestionParams) (GetNextClassicModeQuestionRow, error) {
	row := q.db.QueryRow(ctx, getNextClassicModeQuestion, arg.UserID, arg.GameTypeID, arg.CategoryID)
	var i GetNextClassicModeQuestionRow
	err := row.Scan(
		&i.Text,
		&i.Choices,
		&i.Explanation,
		&i.AnswerIndex,
		&i.ID,
	)
	return i, err
}

const hasUnsolvedQuestions = `-- name: HasUnsolvedQuestions :one
SELECT EXISTS (SELECT 1
               FROM user_progresses up
                        JOIN questions q ON up.question_id = q.id
               WHERE up.user_id = $1
                 AND up.status = 'unsolved'
                 AND q.game_type_id = $2)
`

type HasUnsolvedQuestionsParams struct {
	UserID     int64 `db:"user_id" json:"user_id"`
	GameTypeID int32 `db:"game_type_id" json:"game_type_id"`
}

// HasUnsolvedQuestions
//
//	SELECT EXISTS (SELECT 1
//	               FROM user_progresses up
//	                        JOIN questions q ON up.question_id = q.id
//	               WHERE up.user_id = $1
//	                 AND up.status = 'unsolved'
//	                 AND q.game_type_id = $2)
func (q *Queries) HasUnsolvedQuestions(ctx context.Context, arg HasUnsolvedQuestionsParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasUnsolvedQuestions, arg.UserID, arg.GameTypeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const resetUserProgress = `-- name: ResetUserProgress :exec
UPDATE user_progresses
SET status = 'unsolved'
WHERE user_id = $1
  AND question_id IN (SELECT id
                      FROM questions
                      WHERE game_type_id = $2)
`

type ResetUserProgressParams struct {
	UserID     int64 `db:"user_id" json:"user_id"`
	GameTypeID int32 `db:"game_type_id" json:"game_type_id"`
}

// ResetUserProgress
//
//	UPDATE user_progresses
//	SET status = 'unsolved'
//	WHERE user_id = $1
//	  AND question_id IN (SELECT id
//	                      FROM questions
//	                      WHERE game_type_id = $2)
func (q *Queries) ResetUserProgress(ctx context.Context, arg ResetUserProgressParams) error {
	_, err := q.db.Exec(ctx, resetUserProgress, arg.UserID, arg.GameTypeID)
	return err
}

const skipQuestion = `-- name: SkipQuestion :exec
UPDATE user_progresses
SET status     = 'skipped',
    updated_at = NOW()
WHERE user_id = $1
  AND question_id = $2
`

type SkipQuestionParams struct {
	UserID     int64 `db:"user_id" json:"user_id"`
	QuestionID int32 `db:"question_id" json:"question_id"`
}

// SkipQuestion
//
//	UPDATE user_progresses
//	SET status     = 'skipped',
//	    updated_at = NOW()
//	WHERE user_id = $1
//	  AND question_id = $2
func (q *Queries) SkipQuestion(ctx context.Context, arg SkipQuestionParams) error {
	_, err := q.db.Exec(ctx, skipQuestion, arg.UserID, arg.QuestionID)
	return err
}

const updateUserProgress = `-- name: UpdateUserProgress :exec
UPDATE user_progresses
SET status = $3
WHERE user_id = $1
  AND question_id = $2
`

type UpdateUserProgressParams struct {
	UserID     int64          `db:"user_id" json:"user_id"`
	QuestionID int32          `db:"question_id" json:"question_id"`
	Status     QuestionStatus `db:"status" json:"status"`
}

// UpdateUserProgress
//
//	UPDATE user_progresses
//	SET status = $3
//	WHERE user_id = $1
//	  AND question_id = $2
func (q *Queries) UpdateUserProgress(ctx context.Context, arg UpdateUserProgressParams) error {
	_, err := q.db.Exec(ctx, updateUserProgress, arg.UserID, arg.QuestionID, arg.Status)
	return err
}
