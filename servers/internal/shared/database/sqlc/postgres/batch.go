// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: batch.go

package sqlc

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const createCategories = `-- name: CreateCategories :batchone
INSERT INTO categories (id, display_order, name)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateCategoriesBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateCategoriesParams struct {
	ID           int32  `db:"id" json:"id"`
	DisplayOrder int32  `db:"display_order" json:"display_order"`
	Name         string `db:"name" json:"name"`
}

// CreateCategories
//
//	INSERT INTO categories (id, display_order, name)
//	VALUES ($1, $2, $3)
//	RETURNING id
func (q *Queries) CreateCategories(ctx context.Context, arg []CreateCategoriesParams) *CreateCategoriesBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.DisplayOrder,
			a.Name,
		}
		batch.Queue(createCategories, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateCategoriesBatchResults{br, len(arg), false}
}

func (b *CreateCategoriesBatchResults) QueryRow(f func(int, int32, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		var id int32
		if b.closed {
			if f != nil {
				f(t, id, ErrBatchAlreadyClosed)
			}
			continue
		}
		row := b.br.QueryRow()
		err := row.Scan(&id)
		if f != nil {
			f(t, id, err)
		}
	}
}

func (b *CreateCategoriesBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createNewUserProgress = `-- name: CreateNewUserProgress :batchexec
INSERT INTO user_progresses (user_id, question_id, status, updated_at)
VALUES ($1, $2, $3, $4)
`

type CreateNewUserProgressBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateNewUserProgressParams struct {
	UserID     int64              `db:"user_id" json:"user_id"`
	QuestionID int32              `db:"question_id" json:"question_id"`
	Status     QuestionStatus     `db:"status" json:"status"`
	UpdatedAt  pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

// CreateNewUserProgress
//
//	INSERT INTO user_progresses (user_id, question_id, status, updated_at)
//	VALUES ($1, $2, $3, $4)
func (q *Queries) CreateNewUserProgress(ctx context.Context, arg []CreateNewUserProgressParams) *CreateNewUserProgressBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.UserID,
			a.QuestionID,
			a.Status,
			a.UpdatedAt,
		}
		batch.Queue(createNewUserProgress, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateNewUserProgressBatchResults{br, len(arg), false}
}

func (b *CreateNewUserProgressBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateNewUserProgressBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const upsertUserQuestionStats = `-- name: UpsertUserQuestionStats :batchexec
INSERT INTO user_question_stats (
        user_id,
        category_name,
        answered_question_count,
        total_question_count,
        correct_question_count
    )
VALUES ($1, $2, $3, $4, $5) ON CONFLICT (user_id, category_name) DO
UPDATE
SET answered_question_count = EXCLUDED.answered_question_count,
    total_question_count = EXCLUDED.total_question_count,
    correct_question_count = EXCLUDED.correct_question_count,
    updated_at = now()
RETURNING id, user_id, category_name, answered_question_count, total_question_count, correct_question_count, created_at, updated_at
`

type UpsertUserQuestionStatsBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type UpsertUserQuestionStatsParams struct {
	UserID                int64  `db:"user_id" json:"user_id"`
	CategoryName          string `db:"category_name" json:"category_name"`
	AnsweredQuestionCount int32  `db:"answered_question_count" json:"answered_question_count"`
	TotalQuestionCount    int32  `db:"total_question_count" json:"total_question_count"`
	CorrectQuestionCount  int32  `db:"correct_question_count" json:"correct_question_count"`
}

// UpsertUserQuestionStats
//
//	INSERT INTO user_question_stats (
//	        user_id,
//	        category_name,
//	        answered_question_count,
//	        total_question_count,
//	        correct_question_count
//	    )
//	VALUES ($1, $2, $3, $4, $5) ON CONFLICT (user_id, category_name) DO
//	UPDATE
//	SET answered_question_count = EXCLUDED.answered_question_count,
//	    total_question_count = EXCLUDED.total_question_count,
//	    correct_question_count = EXCLUDED.correct_question_count,
//	    updated_at = now()
//	RETURNING id, user_id, category_name, answered_question_count, total_question_count, correct_question_count, created_at, updated_at
func (q *Queries) UpsertUserQuestionStats(ctx context.Context, arg []UpsertUserQuestionStatsParams) *UpsertUserQuestionStatsBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.UserID,
			a.CategoryName,
			a.AnsweredQuestionCount,
			a.TotalQuestionCount,
			a.CorrectQuestionCount,
		}
		batch.Queue(upsertUserQuestionStats, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &UpsertUserQuestionStatsBatchResults{br, len(arg), false}
}

func (b *UpsertUserQuestionStatsBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *UpsertUserQuestionStatsBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
