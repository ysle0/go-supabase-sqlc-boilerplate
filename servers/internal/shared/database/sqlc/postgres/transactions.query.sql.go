// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTransactions = `-- name: CountTransactions :one
SELECT COUNT(*) FROM transactions
`

// CountTransactions
//
//	SELECT COUNT(*) FROM transactions
func (q *Queries) CountTransactions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countTransactions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTransactionsByUserID = `-- name: CountTransactionsByUserID :one
SELECT COUNT(*) FROM transactions
WHERE user_id = $1
`

// CountTransactionsByUserID
//
//	SELECT COUNT(*) FROM transactions
//	WHERE user_id = $1
func (q *Queries) CountTransactionsByUserID(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countTransactionsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    user_id,
    item_id,
    transaction_type,
    quantity,
    amount,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, item_id, transaction_type, quantity, amount, notes, created_at
`

type CreateTransactionParams struct {
	UserID          int64          `db:"user_id" json:"user_id"`
	ItemID          int64          `db:"item_id" json:"item_id"`
	TransactionType string         `db:"transaction_type" json:"transaction_type"`
	Quantity        int32          `db:"quantity" json:"quantity"`
	Amount          pgtype.Numeric `db:"amount" json:"amount"`
	Notes           pgtype.Text    `db:"notes" json:"notes"`
}

// CreateTransaction
//
//	INSERT INTO transactions (
//	    user_id,
//	    item_id,
//	    transaction_type,
//	    quantity,
//	    amount,
//	    notes
//	) VALUES (
//	    $1, $2, $3, $4, $5, $6
//	) RETURNING id, user_id, item_id, transaction_type, quantity, amount, notes, created_at
func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.UserID,
		arg.ItemID,
		arg.TransactionType,
		arg.Quantity,
		arg.Amount,
		arg.Notes,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.TransactionType,
		&i.Quantity,
		&i.Amount,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, user_id, item_id, transaction_type, quantity, amount, notes, created_at FROM transactions
WHERE id = $1
LIMIT 1
`

// GetTransactionByID
//
//	SELECT id, user_id, item_id, transaction_type, quantity, amount, notes, created_at FROM transactions
//	WHERE id = $1
//	LIMIT 1
func (q *Queries) GetTransactionByID(ctx context.Context, id int64) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ItemID,
		&i.TransactionType,
		&i.Quantity,
		&i.Amount,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getTransactionsByDateRange = `-- name: GetTransactionsByDateRange :many
SELECT id, user_id, item_id, transaction_type, quantity, amount, notes, created_at FROM transactions
WHERE created_at >= $1 AND created_at <= $2
ORDER BY created_at DESC
`

type GetTransactionsByDateRangeParams struct {
	CreatedAt   pgtype.Timestamptz `db:"created_at" json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `db:"created_at_2" json:"created_at_2"`
}

// GetTransactionsByDateRange
//
//	SELECT id, user_id, item_id, transaction_type, quantity, amount, notes, created_at FROM transactions
//	WHERE created_at >= $1 AND created_at <= $2
//	ORDER BY created_at DESC
func (q *Queries) GetTransactionsByDateRange(ctx context.Context, arg GetTransactionsByDateRangeParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByDateRange, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ItemID,
			&i.TransactionType,
			&i.Quantity,
			&i.Amount,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTransactionSummary = `-- name: GetUserTransactionSummary :one
SELECT
    user_id,
    COUNT(*) as total_transactions,
    SUM(amount) as total_amount,
    SUM(CASE WHEN transaction_type = 'purchase' THEN 1 ELSE 0 END) as purchase_count,
    SUM(CASE WHEN transaction_type = 'refund' THEN 1 ELSE 0 END) as refund_count
FROM transactions
WHERE user_id = $1
GROUP BY user_id
`

type GetUserTransactionSummaryRow struct {
	UserID            int64 `db:"user_id" json:"user_id"`
	TotalTransactions int64 `db:"total_transactions" json:"total_transactions"`
	TotalAmount       int64 `db:"total_amount" json:"total_amount"`
	PurchaseCount     int64 `db:"purchase_count" json:"purchase_count"`
	RefundCount       int64 `db:"refund_count" json:"refund_count"`
}

// GetUserTransactionSummary
//
//	SELECT
//	    user_id,
//	    COUNT(*) as total_transactions,
//	    SUM(amount) as total_amount,
//	    SUM(CASE WHEN transaction_type = 'purchase' THEN 1 ELSE 0 END) as purchase_count,
//	    SUM(CASE WHEN transaction_type = 'refund' THEN 1 ELSE 0 END) as refund_count
//	FROM transactions
//	WHERE user_id = $1
//	GROUP BY user_id
func (q *Queries) GetUserTransactionSummary(ctx context.Context, userID int64) (GetUserTransactionSummaryRow, error) {
	row := q.db.QueryRow(ctx, getUserTransactionSummary, userID)
	var i GetUserTransactionSummaryRow
	err := row.Scan(
		&i.UserID,
		&i.TotalTransactions,
		&i.TotalAmount,
		&i.PurchaseCount,
		&i.RefundCount,
	)
	return i, err
}

const listTransactions = `-- name: ListTransactions :many
SELECT id, user_id, item_id, transaction_type, quantity, amount, notes, created_at FROM transactions
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListTransactionsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

// ListTransactions
//
//	SELECT id, user_id, item_id, transaction_type, quantity, amount, notes, created_at FROM transactions
//	ORDER BY created_at DESC
//	LIMIT $1 OFFSET $2
func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ItemID,
			&i.TransactionType,
			&i.Quantity,
			&i.Amount,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByItemID = `-- name: ListTransactionsByItemID :many
SELECT id, user_id, item_id, transaction_type, quantity, amount, notes, created_at FROM transactions
WHERE item_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListTransactionsByItemIDParams struct {
	ItemID int64 `db:"item_id" json:"item_id"`
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

// ListTransactionsByItemID
//
//	SELECT id, user_id, item_id, transaction_type, quantity, amount, notes, created_at FROM transactions
//	WHERE item_id = $1
//	ORDER BY created_at DESC
//	LIMIT $2 OFFSET $3
func (q *Queries) ListTransactionsByItemID(ctx context.Context, arg ListTransactionsByItemIDParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByItemID, arg.ItemID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ItemID,
			&i.TransactionType,
			&i.Quantity,
			&i.Amount,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByUserID = `-- name: ListTransactionsByUserID :many
SELECT id, user_id, item_id, transaction_type, quantity, amount, notes, created_at FROM transactions
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListTransactionsByUserIDParams struct {
	UserID int64 `db:"user_id" json:"user_id"`
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

// ListTransactionsByUserID
//
//	SELECT id, user_id, item_id, transaction_type, quantity, amount, notes, created_at FROM transactions
//	WHERE user_id = $1
//	ORDER BY created_at DESC
//	LIMIT $2 OFFSET $3
func (q *Queries) ListTransactionsByUserID(ctx context.Context, arg ListTransactionsByUserIDParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ItemID,
			&i.TransactionType,
			&i.Quantity,
			&i.Amount,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
