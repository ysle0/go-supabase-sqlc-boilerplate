// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createNewUserWithDefaultValues = `-- name: CreateNewUserWithDefaultValues :one
INSERT INTO users (oauth_id, gem_balance, coin_balance, country_code)
VALUES ($1, $2, $3, $4)
RETURNING id, oauth_id, public_id, nickname, profile_index, crown_amount, gem_balance, coin_balance, hint_quantity, skip_quantity, country_code, is_deleted, created_at, updated_at, deleted_at
`

type CreateNewUserWithDefaultValuesParams struct {
	OauthID     pgtype.UUID `db:"oauth_id" json:"oauth_id"`
	GemBalance  int32       `db:"gem_balance" json:"gem_balance"`
	CoinBalance int32       `db:"coin_balance" json:"coin_balance"`
	CountryCode string      `db:"country_code" json:"country_code"`
}

// CreateNewUserWithDefaultValues
//
//	INSERT INTO users (oauth_id, gem_balance, coin_balance, country_code)
//	VALUES ($1, $2, $3, $4)
//	RETURNING id, oauth_id, public_id, nickname, profile_index, crown_amount, gem_balance, coin_balance, hint_quantity, skip_quantity, country_code, is_deleted, created_at, updated_at, deleted_at
func (q *Queries) CreateNewUserWithDefaultValues(ctx context.Context, arg CreateNewUserWithDefaultValuesParams) (User, error) {
	row := q.db.QueryRow(ctx, createNewUserWithDefaultValues,
		arg.OauthID,
		arg.GemBalance,
		arg.CoinBalance,
		arg.CountryCode,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OauthID,
		&i.PublicID,
		&i.Nickname,
		&i.ProfileIndex,
		&i.CrownAmount,
		&i.GemBalance,
		&i.CoinBalance,
		&i.HintQuantity,
		&i.SkipQuantity,
		&i.CountryCode,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCoinAndGemBalance = `-- name: GetCoinAndGemBalance :one
SELECT coin_balance,
       gem_balance
FROM users
WHERE id = $1
`

type GetCoinAndGemBalanceRow struct {
	CoinBalance int32 `db:"coin_balance" json:"coin_balance"`
	GemBalance  int32 `db:"gem_balance" json:"gem_balance"`
}

// GetCoinAndGemBalance
//
//	SELECT coin_balance,
//	       gem_balance
//	FROM users
//	WHERE id = $1
func (q *Queries) GetCoinAndGemBalance(ctx context.Context, id int64) (GetCoinAndGemBalanceRow, error) {
	row := q.db.QueryRow(ctx, getCoinAndGemBalance, id)
	var i GetCoinAndGemBalanceRow
	err := row.Scan(&i.CoinBalance, &i.GemBalance)
	return i, err
}

const getCoinAndGemBalanceByPublicId = `-- name: GetCoinAndGemBalanceByPublicId :one
SELECT coin_balance,
       gem_balance
FROM users
WHERE public_id = $1
`

type GetCoinAndGemBalanceByPublicIdRow struct {
	CoinBalance int32 `db:"coin_balance" json:"coin_balance"`
	GemBalance  int32 `db:"gem_balance" json:"gem_balance"`
}

// GetCoinAndGemBalanceByPublicId
//
//	SELECT coin_balance,
//	       gem_balance
//	FROM users
//	WHERE public_id = $1
func (q *Queries) GetCoinAndGemBalanceByPublicId(ctx context.Context, publicID pgtype.UUID) (GetCoinAndGemBalanceByPublicIdRow, error) {
	row := q.db.QueryRow(ctx, getCoinAndGemBalanceByPublicId, publicID)
	var i GetCoinAndGemBalanceByPublicIdRow
	err := row.Scan(&i.CoinBalance, &i.GemBalance)
	return i, err
}

const getCoinBalance = `-- name: GetCoinBalance :one
SELECT coin_balance
FROM users
WHERE id = $1
`

// GetCoinBalance
//
//	SELECT coin_balance
//	FROM users
//	WHERE id = $1
func (q *Queries) GetCoinBalance(ctx context.Context, id int64) (int32, error) {
	row := q.db.QueryRow(ctx, getCoinBalance, id)
	var coin_balance int32
	err := row.Scan(&coin_balance)
	return coin_balance, err
}

const getCoinBalanceByPublicId = `-- name: GetCoinBalanceByPublicId :one
SELECT coin_balance
FROM users
WHERE public_id = $1
`

// GetCoinBalanceByPublicId
//
//	SELECT coin_balance
//	FROM users
//	WHERE public_id = $1
func (q *Queries) GetCoinBalanceByPublicId(ctx context.Context, publicID pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getCoinBalanceByPublicId, publicID)
	var coin_balance int32
	err := row.Scan(&coin_balance)
	return coin_balance, err
}

const getCrownAmount = `-- name: GetCrownAmount :one
SELECT crown_amount
FROM users
WHERE id = $1
`

// GetCrownAmount
//
//	SELECT crown_amount
//	FROM users
//	WHERE id = $1
func (q *Queries) GetCrownAmount(ctx context.Context, id int64) (int32, error) {
	row := q.db.QueryRow(ctx, getCrownAmount, id)
	var crown_amount int32
	err := row.Scan(&crown_amount)
	return crown_amount, err
}

const getGemBalance = `-- name: GetGemBalance :one
SELECT gem_balance
FROM users
WHERE id = $1
`

// GetGemBalance
//
//	SELECT gem_balance
//	FROM users
//	WHERE id = $1
func (q *Queries) GetGemBalance(ctx context.Context, id int64) (int32, error) {
	row := q.db.QueryRow(ctx, getGemBalance, id)
	var gem_balance int32
	err := row.Scan(&gem_balance)
	return gem_balance, err
}

const getGemBalanceByPublicId = `-- name: GetGemBalanceByPublicId :one
SELECT gem_balance
FROM users
WHERE public_id = $1
`

// GetGemBalanceByPublicId
//
//	SELECT gem_balance
//	FROM users
//	WHERE public_id = $1
func (q *Queries) GetGemBalanceByPublicId(ctx context.Context, publicID pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getGemBalanceByPublicId, publicID)
	var gem_balance int32
	err := row.Scan(&gem_balance)
	return gem_balance, err
}

const getInternalUserId = `-- name: GetInternalUserId :one
SELECT id
FROM users
WHERE public_id = $1
LIMIT 1
`

// user
//
//	SELECT id
//	FROM users
//	WHERE public_id = $1
//	LIMIT 1
func (q *Queries) GetInternalUserId(ctx context.Context, publicID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getInternalUserId, publicID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getUserByInternalId = `-- name: GetUserByInternalId :many
SELECT id, oauth_id, public_id, nickname, profile_index, crown_amount, gem_balance, coin_balance, hint_quantity, skip_quantity, country_code, is_deleted, created_at, updated_at, deleted_at
FROM users
WHERE users.id = ANY ($1::int[])
`

// GetUserByInternalId
//
//	SELECT id, oauth_id, public_id, nickname, profile_index, crown_amount, gem_balance, coin_balance, hint_quantity, skip_quantity, country_code, is_deleted, created_at, updated_at, deleted_at
//	FROM users
//	WHERE users.id = ANY ($1::int[])
func (q *Queries) GetUserByInternalId(ctx context.Context, dollar_1 []int32) ([]User, error) {
	rows, err := q.db.Query(ctx, getUserByInternalId, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.OauthID,
			&i.PublicID,
			&i.Nickname,
			&i.ProfileIndex,
			&i.CrownAmount,
			&i.GemBalance,
			&i.CoinBalance,
			&i.HintQuantity,
			&i.SkipQuantity,
			&i.CountryCode,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByPublicId = `-- name: GetUserByPublicId :one
SELECT id, oauth_id, public_id, nickname, profile_index, crown_amount, gem_balance, coin_balance, hint_quantity, skip_quantity, country_code, is_deleted, created_at, updated_at, deleted_at
FROM users
WHERE public_id = $1
`

// GetUserByPublicId
//
//	SELECT id, oauth_id, public_id, nickname, profile_index, crown_amount, gem_balance, coin_balance, hint_quantity, skip_quantity, country_code, is_deleted, created_at, updated_at, deleted_at
//	FROM users
//	WHERE public_id = $1
func (q *Queries) GetUserByPublicId(ctx context.Context, publicID pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByPublicId, publicID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.OauthID,
		&i.PublicID,
		&i.Nickname,
		&i.ProfileIndex,
		&i.CrownAmount,
		&i.GemBalance,
		&i.CoinBalance,
		&i.HintQuantity,
		&i.SkipQuantity,
		&i.CountryCode,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserNamesByInternalId = `-- name: GetUserNamesByInternalId :many
SELECT nickname
FROM users
WHERE users.id = ANY ($1::int[])
`

// GetUserNamesByInternalId
//
//	SELECT nickname
//	FROM users
//	WHERE users.id = ANY ($1::int[])
func (q *Queries) GetUserNamesByInternalId(ctx context.Context, dollar_1 []int32) ([]string, error) {
	rows, err := q.db.Query(ctx, getUserNamesByInternalId, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var nickname string
		if err := rows.Scan(&nickname); err != nil {
			return nil, err
		}
		items = append(items, nickname)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasUserByOAuthId = `-- name: HasUserByOAuthId :one
SELECT COUNT(*) > 0
FROM users
WHERE oauth_id = $1
`

// HasUserByOAuthId
//
//	SELECT COUNT(*) > 0
//	FROM users
//	WHERE oauth_id = $1
func (q *Queries) HasUserByOAuthId(ctx context.Context, oauthID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, hasUserByOAuthId, oauthID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const isNicknameSet = `-- name: IsNicknameSet :one
SELECT (COUNT(nickname) > 0) AND (nickname != '')
FROM users
WHERE public_id = $1
`

// profile
//
//	SELECT (COUNT(nickname) > 0) AND (nickname != '')
//	FROM users
//	WHERE public_id = $1
func (q *Queries) IsNicknameSet(ctx context.Context, publicID pgtype.UUID) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, isNicknameSet, publicID)
	var column_1 pgtype.Bool
	err := row.Scan(&column_1)
	return column_1, err
}

const updateCoinBalance = `-- name: UpdateCoinBalance :exec
UPDATE users
SET coin_balance = $2
WHERE id = $1
`

type UpdateCoinBalanceParams struct {
	ID          int64 `db:"id" json:"id"`
	CoinBalance int32 `db:"coin_balance" json:"coin_balance"`
}

// UpdateCoinBalance
//
//	UPDATE users
//	SET coin_balance = $2
//	WHERE id = $1
func (q *Queries) UpdateCoinBalance(ctx context.Context, arg UpdateCoinBalanceParams) error {
	_, err := q.db.Exec(ctx, updateCoinBalance, arg.ID, arg.CoinBalance)
	return err
}

const updateGemBalance = `-- name: UpdateGemBalance :exec
UPDATE users
SET gem_balance = $2
WHERE id = $1
`

type UpdateGemBalanceParams struct {
	ID         int64 `db:"id" json:"id"`
	GemBalance int32 `db:"gem_balance" json:"gem_balance"`
}

// UpdateGemBalance
//
//	UPDATE users
//	SET gem_balance = $2
//	WHERE id = $1
func (q *Queries) UpdateGemBalance(ctx context.Context, arg UpdateGemBalanceParams) error {
	_, err := q.db.Exec(ctx, updateGemBalance, arg.ID, arg.GemBalance)
	return err
}

const updateUserBalance = `-- name: UpdateUserBalance :exec

UPDATE users
SET gem_balance  = $2,
    coin_balance = $3
WHERE id = $1
`

type UpdateUserBalanceParams struct {
	ID          int64 `db:"id" json:"id"`
	GemBalance  int32 `db:"gem_balance" json:"gem_balance"`
	CoinBalance int32 `db:"coin_balance" json:"coin_balance"`
}

// currency
//
//	UPDATE users
//	SET gem_balance  = $2,
//	    coin_balance = $3
//	WHERE id = $1
func (q *Queries) UpdateUserBalance(ctx context.Context, arg UpdateUserBalanceParams) error {
	_, err := q.db.Exec(ctx, updateUserBalance, arg.ID, arg.GemBalance, arg.CoinBalance)
	return err
}

const updateUserCrownAmount = `-- name: UpdateUserCrownAmount :exec
UPDATE users
SET crown_amount = $2
WHERE id = $1
`

type UpdateUserCrownAmountParams struct {
	ID          int64 `db:"id" json:"id"`
	CrownAmount int32 `db:"crown_amount" json:"crown_amount"`
}

// UpdateUserCrownAmount
//
//	UPDATE users
//	SET crown_amount = $2
//	WHERE id = $1
func (q *Queries) UpdateUserCrownAmount(ctx context.Context, arg UpdateUserCrownAmountParams) error {
	_, err := q.db.Exec(ctx, updateUserCrownAmount, arg.ID, arg.CrownAmount)
	return err
}

const updateUserNickname = `-- name: UpdateUserNickname :exec
UPDATE users
SET nickname = $2
WHERE id = $1
`

type UpdateUserNicknameParams struct {
	ID       int64  `db:"id" json:"id"`
	Nickname string `db:"nickname" json:"nickname"`
}

// UpdateUserNickname
//
//	UPDATE users
//	SET nickname = $2
//	WHERE id = $1
func (q *Queries) UpdateUserNickname(ctx context.Context, arg UpdateUserNicknameParams) error {
	_, err := q.db.Exec(ctx, updateUserNickname, arg.ID, arg.Nickname)
	return err
}

const updateUserProfile = `-- name: UpdateUserProfile :exec
UPDATE users
SET profile_index = $2,
    nickname      = $3
WHERE id = $1
`

type UpdateUserProfileParams struct {
	ID           int64  `db:"id" json:"id"`
	ProfileIndex int32  `db:"profile_index" json:"profile_index"`
	Nickname     string `db:"nickname" json:"nickname"`
}

// UpdateUserProfile
//
//	UPDATE users
//	SET profile_index = $2,
//	    nickname      = $3
//	WHERE id = $1
func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) error {
	_, err := q.db.Exec(ctx, updateUserProfile, arg.ID, arg.ProfileIndex, arg.Nickname)
	return err
}
