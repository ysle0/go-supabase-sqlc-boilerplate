package helpers

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
	sqlc "github.com/your-org/go-monorepo-boilerplate/servers/internal/shared/database/sqlc/postgres"
)

// TestFixtures provides helper methods for creating test data
type TestFixtures struct {
	Pool    *pgxpool.Pool
	Queries *sqlc.Queries
}

// NewTestFixtures creates a new TestFixtures instance
func NewTestFixtures(pool *pgxpool.Pool) *TestFixtures {
	return &TestFixtures{
		Pool:    pool,
		Queries: sqlc.New(pool),
	}
}

// ============================================================================
// User Fixture Methods (matching schema.sql) - Using SQLC
// ============================================================================

// CreateUser creates a user with flexible parameters for the boilerplate schema
// Accepts a map with optional fields: public_id, email, username, display_name
// If public_id is provided, it will be used, otherwise it's auto-generated by the database
func (f *TestFixtures) CreateUser(ctx context.Context, params map[string]any) (*sqlc.User, error) {
	email, ok := params["email"].(string)
	if !ok {
		return nil, fmt.Errorf("email is required")
	}

	username, ok := params["username"].(string)
	if !ok {
		return nil, fmt.Errorf("username is required")
	}

	displayName := pgtype.Text{}
	if d, ok := params["display_name"].(string); ok {
		displayName = pgtype.Text{String: d, Valid: true}
	}

	// Check if public_id is provided
	if publicID, ok := params["public_id"].(pgtype.UUID); ok {
		// Use raw SQL to insert with explicit public_id
		query := `
			INSERT INTO users (public_id, email, username, display_name)
			VALUES ($1, $2, $3, $4)
			RETURNING id, public_id, email, username, display_name, created_at, updated_at, deleted_at
		`

		var user sqlc.User
		err := f.Pool.QueryRow(ctx, query, publicID, email, username, displayName).Scan(
			&user.ID,
			&user.PublicID,
			&user.Email,
			&user.Username,
			&user.DisplayName,
			&user.CreatedAt,
			&user.UpdatedAt,
			&user.DeletedAt,
		)

		if err != nil {
			return nil, fmt.Errorf("failed to create user with public_id: %w", err)
		}

		return &user, nil
	}

	// Use SQLC for auto-generated public_id
	user, err := f.Queries.CreateUser(ctx, sqlc.CreateUserParams{
		Email:       email,
		Username:    username,
		DisplayName: displayName,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	return &user, nil
}

// GetUserByPublicID retrieves a user by their public ID using SQLC
func (f *TestFixtures) GetUserByPublicID(ctx context.Context, publicID pgtype.UUID) (*sqlc.User, error) {
	user, err := f.Queries.GetUserByPublicID(ctx, publicID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user by public ID: %w", err)
	}
	return &user, nil
}

// GetUserByEmail retrieves a user by their email using SQLC
func (f *TestFixtures) GetUserByEmail(ctx context.Context, email string) (*sqlc.User, error) {
	user, err := f.Queries.GetUserByEmail(ctx, email)
	if err != nil {
		return nil, fmt.Errorf("failed to get user by email: %w", err)
	}
	return &user, nil
}

// GetUserByUsername retrieves a user by their username using SQLC
func (f *TestFixtures) GetUserByUsername(ctx context.Context, username string) (*sqlc.User, error) {
	user, err := f.Queries.GetUserByUsername(ctx, username)
	if err != nil {
		return nil, fmt.Errorf("failed to get user by username: %w", err)
	}
	return &user, nil
}

// CountUsers returns the total number of active users using SQLC
func (f *TestFixtures) CountUsers(ctx context.Context) (int64, error) {
	count, err := f.Queries.CountUsers(ctx)
	if err != nil {
		return 0, fmt.Errorf("failed to count users: %w", err)
	}
	return count, nil
}

// SoftDeleteUser soft deletes a user by their public ID using raw SQL
// Note: SQLC's SoftDeleteUser uses ID, but we need PublicID for tests
func (f *TestFixtures) SoftDeleteUser(ctx context.Context, publicID pgtype.UUID) error {
	query := `
		UPDATE users
		SET deleted_at = NOW()
		WHERE public_id = $1 AND deleted_at IS NULL
	`

	_, err := f.Pool.Exec(ctx, query, publicID)
	if err != nil {
		return fmt.Errorf("failed to soft delete user: %w", err)
	}

	return nil
}

// ============================================================================
// Item Fixture Methods (matching schema.sql)
// ============================================================================

// CreateItem creates an item with the given parameters
func (f *TestFixtures) CreateItem(ctx context.Context, name, description string, price float64, quantity int32) (*sqlc.Item, error) {
	query := `
		INSERT INTO items (name, description, price, quantity)
		VALUES ($1, $2, $3, $4)
		RETURNING id, name, description, price, quantity, created_at, updated_at
	`

	desc := pgtype.Text{}
	if description != "" {
		desc = pgtype.Text{String: description, Valid: true}
	}

	var item sqlc.Item
	err := f.Pool.QueryRow(ctx, query, name, desc, price, quantity).Scan(
		&item.ID,
		&item.Name,
		&item.Description,
		&item.Price,
		&item.Quantity,
		&item.CreatedAt,
		&item.UpdatedAt,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to create item: %w", err)
	}

	return &item, nil
}

// GetItemByID retrieves an item by its ID
func (f *TestFixtures) GetItemByID(ctx context.Context, id int64) (*sqlc.Item, error) {
	query := `
		SELECT id, name, description, price, quantity, created_at, updated_at
		FROM items
		WHERE id = $1
	`

	var item sqlc.Item
	err := f.Pool.QueryRow(ctx, query, id).Scan(
		&item.ID,
		&item.Name,
		&item.Description,
		&item.Price,
		&item.Quantity,
		&item.CreatedAt,
		&item.UpdatedAt,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to get item by ID: %w", err)
	}

	return &item, nil
}

// ============================================================================
// Transaction Fixture Methods (matching schema.sql)
// ============================================================================

// CreateTransaction creates a transaction record
func (f *TestFixtures) CreateTransaction(ctx context.Context, userID, itemID int64, transactionType string, quantity int32, amount float64, notes string) (*sqlc.Transaction, error) {
	query := `
		INSERT INTO transactions (user_id, item_id, transaction_type, quantity, amount, notes)
		VALUES ($1, $2, $3, $4, $5, $6)
		RETURNING id, user_id, item_id, transaction_type, quantity, amount, notes, created_at
	`

	notesText := pgtype.Text{}
	if notes != "" {
		notesText = pgtype.Text{String: notes, Valid: true}
	}

	var tx sqlc.Transaction
	err := f.Pool.QueryRow(ctx, query, userID, itemID, transactionType, quantity, amount, notesText).Scan(
		&tx.ID,
		&tx.UserID,
		&tx.ItemID,
		&tx.TransactionType,
		&tx.Quantity,
		&tx.Amount,
		&tx.Notes,
		&tx.CreatedAt,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to create transaction: %w", err)
	}

	return &tx, nil
}

// GetTransactionsByUserID retrieves all transactions for a user
func (f *TestFixtures) GetTransactionsByUserID(ctx context.Context, userID int64) ([]sqlc.Transaction, error) {
	query := `
		SELECT id, user_id, item_id, transaction_type, quantity, amount, notes, created_at
		FROM transactions
		WHERE user_id = $1
		ORDER BY created_at DESC
	`

	rows, err := f.Pool.Query(ctx, query, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get transactions by user ID: %w", err)
	}
	defer rows.Close()

	var transactions []sqlc.Transaction
	for rows.Next() {
		var tx sqlc.Transaction
		if err := rows.Scan(
			&tx.ID,
			&tx.UserID,
			&tx.ItemID,
			&tx.TransactionType,
			&tx.Quantity,
			&tx.Amount,
			&tx.Notes,
			&tx.CreatedAt,
		); err != nil {
			return nil, fmt.Errorf("failed to scan transaction: %w", err)
		}
		transactions = append(transactions, tx)
	}

	return transactions, nil
}
